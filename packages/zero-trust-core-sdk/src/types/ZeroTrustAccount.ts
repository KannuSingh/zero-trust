/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
	AddressLike,
	BaseContract,
	BigNumberish,
	BytesLike,
	ContractMethod,
	ContractRunner,
	EventFragment,
	FunctionFragment,
	Interface,
	Listener,
	Result,
} from "ethers";
import type {
	TypedContractEvent,
	TypedContractMethod,
	TypedDeferredTopicFilter,
	TypedEventLog,
	TypedListener,
	TypedLogDescription,
} from "./common";

export type UserOperationStruct = {
	sender: AddressLike;
	nonce: BigNumberish;
	initCode: BytesLike;
	callData: BytesLike;
	callGasLimit: BigNumberish;
	verificationGasLimit: BigNumberish;
	preVerificationGas: BigNumberish;
	maxFeePerGas: BigNumberish;
	maxPriorityFeePerGas: BigNumberish;
	paymasterAndData: BytesLike;
	signature: BytesLike;
};

export type UserOperationStructOutput = [
	sender: string,
	nonce: bigint,
	initCode: string,
	callData: string,
	callGasLimit: bigint,
	verificationGasLimit: bigint,
	preVerificationGas: bigint,
	maxFeePerGas: bigint,
	maxPriorityFeePerGas: bigint,
	paymasterAndData: string,
	signature: string,
] & {
	sender: string;
	nonce: bigint;
	initCode: string;
	callData: string;
	callGasLimit: bigint;
	verificationGasLimit: bigint;
	preVerificationGas: bigint;
	maxFeePerGas: bigint;
	maxPriorityFeePerGas: bigint;
	paymasterAndData: string;
	signature: string;
};

export declare namespace IPasskeyAccount {
	export type PasskeyStruct = {
		pubKeyX: BigNumberish;
		pubKeyY: BigNumberish;
		credentialId: BytesLike;
	};

	export type PasskeyStructOutput = [
		pubKeyX: bigint,
		pubKeyY: bigint,
		credentialId: string,
	] & { pubKeyX: bigint; pubKeyY: bigint; credentialId: string };

	export type PasskeySigDataStruct = {
		challengeLocation: BigNumberish;
		responseTypeLocation: BigNumberish;
		r: BigNumberish;
		s: BigNumberish;
		requireUserVerification: boolean;
		authenticatorData: BytesLike;
		clientDataJSON: string;
	};

	export type PasskeySigDataStructOutput = [
		challengeLocation: bigint,
		responseTypeLocation: bigint,
		r: bigint,
		s: bigint,
		requireUserVerification: boolean,
		authenticatorData: string,
		clientDataJSON: string,
	] & {
		challengeLocation: bigint;
		responseTypeLocation: bigint;
		r: bigint;
		s: bigint;
		requireUserVerification: boolean;
		authenticatorData: string;
		clientDataJSON: string;
	};
}

export declare namespace ISessionAccount {
	export type SessionStruct = {
		sessionCommitment: BigNumberish;
		allowedContracts: BigNumberish;
		validUntil: BigNumberish;
		validAfter: BigNumberish;
		allowedInactiveDuration: BigNumberish;
		extendWithInactiveDuration: boolean;
	};

	export type SessionStructOutput = [
		sessionCommitment: bigint,
		allowedContracts: bigint,
		validUntil: bigint,
		validAfter: bigint,
		allowedInactiveDuration: bigint,
		extendWithInactiveDuration: boolean,
	] & {
		sessionCommitment: bigint;
		allowedContracts: bigint;
		validUntil: bigint;
		validAfter: bigint;
		allowedInactiveDuration: bigint;
		extendWithInactiveDuration: boolean;
	};

	export type SessionSignatureProofStruct = {
		appName: BytesLike;
		nullifierHash: BigNumberish;
		values: BigNumberish[];
	};

	export type SessionSignatureProofStructOutput = [
		appName: string,
		nullifierHash: bigint,
		values: bigint[],
	] & { appName: string; nullifierHash: bigint; values: bigint[] };
}

export interface ZeroTrustAccountInterface extends Interface {
	getFunction(
		nameOrSignature:
			| "_signer"
			| "addDeposit"
			| "endApplicationSession"
			| "entryPoint"
			| "execute"
			| "executeBatch"
			| "executeOnSession"
			| "getApplicationSession"
			| "getDeposit"
			| "getNonce"
			| "initialize"
			| "onERC1155BatchReceived"
			| "onERC1155Received"
			| "onERC721Received"
			| "passkeySignatureStruct"
			| "proxiableUUID"
			| "sessionSignatureProofStruct"
			| "setApplicationSession"
			| "supportsInterface"
			| "tokensReceived"
			| "upgradeTo"
			| "upgradeToAndCall"
			| "validateUserOp"
			| "withdrawDepositTo",
	): FunctionFragment;

	getEvent(
		nameOrSignatureOrTopic:
			| "AdminChanged"
			| "BeaconUpgraded"
			| "Initialized"
			| "PasskeyZkAccountInitialized"
			| "Upgraded",
	): EventFragment;

	encodeFunctionData(functionFragment: "_signer", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "addDeposit",
		values?: undefined,
	): string;
	encodeFunctionData(
		functionFragment: "endApplicationSession",
		values: [BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "entryPoint",
		values?: undefined,
	): string;
	encodeFunctionData(
		functionFragment: "execute",
		values: [AddressLike, BigNumberish, BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "executeBatch",
		values: [AddressLike[], BigNumberish[], BytesLike[]],
	): string;
	encodeFunctionData(
		functionFragment: "executeOnSession",
		values: [AddressLike, BigNumberish, BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "getApplicationSession",
		values: [BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "getDeposit",
		values?: undefined,
	): string;
	encodeFunctionData(functionFragment: "getNonce", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "initialize",
		values: [BigNumberish, BigNumberish, BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "onERC1155BatchReceived",
		values: [
			AddressLike,
			AddressLike,
			BigNumberish[],
			BigNumberish[],
			BytesLike,
		],
	): string;
	encodeFunctionData(
		functionFragment: "onERC1155Received",
		values: [AddressLike, AddressLike, BigNumberish, BigNumberish, BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "onERC721Received",
		values: [AddressLike, AddressLike, BigNumberish, BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "passkeySignatureStruct",
		values: [IPasskeyAccount.PasskeySigDataStruct],
	): string;
	encodeFunctionData(
		functionFragment: "proxiableUUID",
		values?: undefined,
	): string;
	encodeFunctionData(
		functionFragment: "sessionSignatureProofStruct",
		values: [ISessionAccount.SessionSignatureProofStruct],
	): string;
	encodeFunctionData(
		functionFragment: "setApplicationSession",
		values: [BytesLike, ISessionAccount.SessionStruct],
	): string;
	encodeFunctionData(
		functionFragment: "supportsInterface",
		values: [BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "tokensReceived",
		values: [
			AddressLike,
			AddressLike,
			AddressLike,
			BigNumberish,
			BytesLike,
			BytesLike,
		],
	): string;
	encodeFunctionData(
		functionFragment: "upgradeTo",
		values: [AddressLike],
	): string;
	encodeFunctionData(
		functionFragment: "upgradeToAndCall",
		values: [AddressLike, BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "validateUserOp",
		values: [UserOperationStruct, BytesLike, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "withdrawDepositTo",
		values: [AddressLike, BigNumberish],
	): string;

	decodeFunctionResult(functionFragment: "_signer", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "addDeposit", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "endApplicationSession",
		data: BytesLike,
	): Result;
	decodeFunctionResult(functionFragment: "entryPoint", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "executeBatch",
		data: BytesLike,
	): Result;
	decodeFunctionResult(
		functionFragment: "executeOnSession",
		data: BytesLike,
	): Result;
	decodeFunctionResult(
		functionFragment: "getApplicationSession",
		data: BytesLike,
	): Result;
	decodeFunctionResult(functionFragment: "getDeposit", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "getNonce", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "onERC1155BatchReceived",
		data: BytesLike,
	): Result;
	decodeFunctionResult(
		functionFragment: "onERC1155Received",
		data: BytesLike,
	): Result;
	decodeFunctionResult(
		functionFragment: "onERC721Received",
		data: BytesLike,
	): Result;
	decodeFunctionResult(
		functionFragment: "passkeySignatureStruct",
		data: BytesLike,
	): Result;
	decodeFunctionResult(
		functionFragment: "proxiableUUID",
		data: BytesLike,
	): Result;
	decodeFunctionResult(
		functionFragment: "sessionSignatureProofStruct",
		data: BytesLike,
	): Result;
	decodeFunctionResult(
		functionFragment: "setApplicationSession",
		data: BytesLike,
	): Result;
	decodeFunctionResult(
		functionFragment: "supportsInterface",
		data: BytesLike,
	): Result;
	decodeFunctionResult(
		functionFragment: "tokensReceived",
		data: BytesLike,
	): Result;
	decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "upgradeToAndCall",
		data: BytesLike,
	): Result;
	decodeFunctionResult(
		functionFragment: "validateUserOp",
		data: BytesLike,
	): Result;
	decodeFunctionResult(
		functionFragment: "withdrawDepositTo",
		data: BytesLike,
	): Result;
}

export namespace AdminChangedEvent {
	export type InputTuple = [previousAdmin: AddressLike, newAdmin: AddressLike];
	export type OutputTuple = [previousAdmin: string, newAdmin: string];
	export interface OutputObject {
		previousAdmin: string;
		newAdmin: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace BeaconUpgradedEvent {
	export type InputTuple = [beacon: AddressLike];
	export type OutputTuple = [beacon: string];
	export interface OutputObject {
		beacon: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace InitializedEvent {
	export type InputTuple = [version: BigNumberish];
	export type OutputTuple = [version: bigint];
	export interface OutputObject {
		version: bigint;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace PasskeyZkAccountInitializedEvent {
	export type InputTuple = [
		entryPoint: AddressLike,
		signer: IPasskeyAccount.PasskeyStruct,
	];
	export type OutputTuple = [
		entryPoint: string,
		signer: IPasskeyAccount.PasskeyStructOutput,
	];
	export interface OutputObject {
		entryPoint: string;
		signer: IPasskeyAccount.PasskeyStructOutput;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace UpgradedEvent {
	export type InputTuple = [implementation: AddressLike];
	export type OutputTuple = [implementation: string];
	export interface OutputObject {
		implementation: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export interface ZeroTrustAccount extends BaseContract {
	connect(runner?: ContractRunner | null): ZeroTrustAccount;
	waitForDeployment(): Promise<this>;

	interface: ZeroTrustAccountInterface;

	queryFilter<TCEvent extends TypedContractEvent>(
		event: TCEvent,
		fromBlockOrBlockhash?: string | number | undefined,
		toBlock?: string | number | undefined,
	): Promise<Array<TypedEventLog<TCEvent>>>;
	queryFilter<TCEvent extends TypedContractEvent>(
		filter: TypedDeferredTopicFilter<TCEvent>,
		fromBlockOrBlockhash?: string | number | undefined,
		toBlock?: string | number | undefined,
	): Promise<Array<TypedEventLog<TCEvent>>>;

	on<TCEvent extends TypedContractEvent>(
		event: TCEvent,
		listener: TypedListener<TCEvent>,
	): Promise<this>;
	on<TCEvent extends TypedContractEvent>(
		filter: TypedDeferredTopicFilter<TCEvent>,
		listener: TypedListener<TCEvent>,
	): Promise<this>;

	once<TCEvent extends TypedContractEvent>(
		event: TCEvent,
		listener: TypedListener<TCEvent>,
	): Promise<this>;
	once<TCEvent extends TypedContractEvent>(
		filter: TypedDeferredTopicFilter<TCEvent>,
		listener: TypedListener<TCEvent>,
	): Promise<this>;

	listeners<TCEvent extends TypedContractEvent>(
		event: TCEvent,
	): Promise<Array<TypedListener<TCEvent>>>;
	listeners(eventName?: string): Promise<Array<Listener>>;
	removeAllListeners<TCEvent extends TypedContractEvent>(
		event?: TCEvent,
	): Promise<this>;

	_signer: TypedContractMethod<
		[],
		[
			[bigint, bigint, string] & {
				pubKeyX: bigint;
				pubKeyY: bigint;
				credentialId: string;
			},
		],
		"view"
	>;

	addDeposit: TypedContractMethod<[], [void], "payable">;

	endApplicationSession: TypedContractMethod<
		[appName: BytesLike],
		[void],
		"nonpayable"
	>;

	entryPoint: TypedContractMethod<[], [string], "view">;

	execute: TypedContractMethod<
		[dest: AddressLike, value: BigNumberish, func: BytesLike],
		[void],
		"nonpayable"
	>;

	executeBatch: TypedContractMethod<
		[dest: AddressLike[], value: BigNumberish[], func: BytesLike[]],
		[void],
		"nonpayable"
	>;

	executeOnSession: TypedContractMethod<
		[dest: AddressLike, value: BigNumberish, func: BytesLike],
		[void],
		"nonpayable"
	>;

	getApplicationSession: TypedContractMethod<
		[appName: BytesLike],
		[ISessionAccount.SessionStructOutput],
		"view"
	>;

	getDeposit: TypedContractMethod<[], [bigint], "view">;

	getNonce: TypedContractMethod<[], [bigint], "view">;

	initialize: TypedContractMethod<
		[pubKeyX: BigNumberish, pubKeyY: BigNumberish, credentialId: BytesLike],
		[void],
		"nonpayable"
	>;

	onERC1155BatchReceived: TypedContractMethod<
		[
			arg0: AddressLike,
			arg1: AddressLike,
			arg2: BigNumberish[],
			arg3: BigNumberish[],
			arg4: BytesLike,
		],
		[string],
		"view"
	>;

	onERC1155Received: TypedContractMethod<
		[
			arg0: AddressLike,
			arg1: AddressLike,
			arg2: BigNumberish,
			arg3: BigNumberish,
			arg4: BytesLike,
		],
		[string],
		"view"
	>;

	onERC721Received: TypedContractMethod<
		[arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish, arg3: BytesLike],
		[string],
		"view"
	>;

	passkeySignatureStruct: TypedContractMethod<
		[sig: IPasskeyAccount.PasskeySigDataStruct],
		[void],
		"nonpayable"
	>;

	proxiableUUID: TypedContractMethod<[], [string], "view">;

	sessionSignatureProofStruct: TypedContractMethod<
		[sig: ISessionAccount.SessionSignatureProofStruct],
		[void],
		"nonpayable"
	>;

	setApplicationSession: TypedContractMethod<
		[appName: BytesLike, session: ISessionAccount.SessionStruct],
		[void],
		"nonpayable"
	>;

	supportsInterface: TypedContractMethod<
		[interfaceId: BytesLike],
		[boolean],
		"view"
	>;

	tokensReceived: TypedContractMethod<
		[
			arg0: AddressLike,
			arg1: AddressLike,
			arg2: AddressLike,
			arg3: BigNumberish,
			arg4: BytesLike,
			arg5: BytesLike,
		],
		[void],
		"view"
	>;

	upgradeTo: TypedContractMethod<
		[newImplementation: AddressLike],
		[void],
		"nonpayable"
	>;

	upgradeToAndCall: TypedContractMethod<
		[newImplementation: AddressLike, data: BytesLike],
		[void],
		"payable"
	>;

	validateUserOp: TypedContractMethod<
		[
			userOp: UserOperationStruct,
			userOpHash: BytesLike,
			missingAccountFunds: BigNumberish,
		],
		[bigint],
		"nonpayable"
	>;

	withdrawDepositTo: TypedContractMethod<
		[withdrawAddress: AddressLike, amount: BigNumberish],
		[void],
		"nonpayable"
	>;

	getFunction<T extends ContractMethod = ContractMethod>(
		key: string | FunctionFragment,
	): T;

	getFunction(nameOrSignature: "_signer"): TypedContractMethod<
		[],
		[
			[bigint, bigint, string] & {
				pubKeyX: bigint;
				pubKeyY: bigint;
				credentialId: string;
			},
		],
		"view"
	>;
	getFunction(
		nameOrSignature: "addDeposit",
	): TypedContractMethod<[], [void], "payable">;
	getFunction(
		nameOrSignature: "endApplicationSession",
	): TypedContractMethod<[appName: BytesLike], [void], "nonpayable">;
	getFunction(
		nameOrSignature: "entryPoint",
	): TypedContractMethod<[], [string], "view">;
	getFunction(
		nameOrSignature: "execute",
	): TypedContractMethod<
		[dest: AddressLike, value: BigNumberish, func: BytesLike],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "executeBatch",
	): TypedContractMethod<
		[dest: AddressLike[], value: BigNumberish[], func: BytesLike[]],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "executeOnSession",
	): TypedContractMethod<
		[dest: AddressLike, value: BigNumberish, func: BytesLike],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "getApplicationSession",
	): TypedContractMethod<
		[appName: BytesLike],
		[ISessionAccount.SessionStructOutput],
		"view"
	>;
	getFunction(
		nameOrSignature: "getDeposit",
	): TypedContractMethod<[], [bigint], "view">;
	getFunction(
		nameOrSignature: "getNonce",
	): TypedContractMethod<[], [bigint], "view">;
	getFunction(
		nameOrSignature: "initialize",
	): TypedContractMethod<
		[pubKeyX: BigNumberish, pubKeyY: BigNumberish, credentialId: BytesLike],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "onERC1155BatchReceived",
	): TypedContractMethod<
		[
			arg0: AddressLike,
			arg1: AddressLike,
			arg2: BigNumberish[],
			arg3: BigNumberish[],
			arg4: BytesLike,
		],
		[string],
		"view"
	>;
	getFunction(
		nameOrSignature: "onERC1155Received",
	): TypedContractMethod<
		[
			arg0: AddressLike,
			arg1: AddressLike,
			arg2: BigNumberish,
			arg3: BigNumberish,
			arg4: BytesLike,
		],
		[string],
		"view"
	>;
	getFunction(
		nameOrSignature: "onERC721Received",
	): TypedContractMethod<
		[arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish, arg3: BytesLike],
		[string],
		"view"
	>;
	getFunction(
		nameOrSignature: "passkeySignatureStruct",
	): TypedContractMethod<
		[sig: IPasskeyAccount.PasskeySigDataStruct],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "proxiableUUID",
	): TypedContractMethod<[], [string], "view">;
	getFunction(
		nameOrSignature: "sessionSignatureProofStruct",
	): TypedContractMethod<
		[sig: ISessionAccount.SessionSignatureProofStruct],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "setApplicationSession",
	): TypedContractMethod<
		[appName: BytesLike, session: ISessionAccount.SessionStruct],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "supportsInterface",
	): TypedContractMethod<[interfaceId: BytesLike], [boolean], "view">;
	getFunction(
		nameOrSignature: "tokensReceived",
	): TypedContractMethod<
		[
			arg0: AddressLike,
			arg1: AddressLike,
			arg2: AddressLike,
			arg3: BigNumberish,
			arg4: BytesLike,
			arg5: BytesLike,
		],
		[void],
		"view"
	>;
	getFunction(
		nameOrSignature: "upgradeTo",
	): TypedContractMethod<
		[newImplementation: AddressLike],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "upgradeToAndCall",
	): TypedContractMethod<
		[newImplementation: AddressLike, data: BytesLike],
		[void],
		"payable"
	>;
	getFunction(
		nameOrSignature: "validateUserOp",
	): TypedContractMethod<
		[
			userOp: UserOperationStruct,
			userOpHash: BytesLike,
			missingAccountFunds: BigNumberish,
		],
		[bigint],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "withdrawDepositTo",
	): TypedContractMethod<
		[withdrawAddress: AddressLike, amount: BigNumberish],
		[void],
		"nonpayable"
	>;

	getEvent(
		key: "AdminChanged",
	): TypedContractEvent<
		AdminChangedEvent.InputTuple,
		AdminChangedEvent.OutputTuple,
		AdminChangedEvent.OutputObject
	>;
	getEvent(
		key: "BeaconUpgraded",
	): TypedContractEvent<
		BeaconUpgradedEvent.InputTuple,
		BeaconUpgradedEvent.OutputTuple,
		BeaconUpgradedEvent.OutputObject
	>;
	getEvent(
		key: "Initialized",
	): TypedContractEvent<
		InitializedEvent.InputTuple,
		InitializedEvent.OutputTuple,
		InitializedEvent.OutputObject
	>;
	getEvent(
		key: "PasskeyZkAccountInitialized",
	): TypedContractEvent<
		PasskeyZkAccountInitializedEvent.InputTuple,
		PasskeyZkAccountInitializedEvent.OutputTuple,
		PasskeyZkAccountInitializedEvent.OutputObject
	>;
	getEvent(
		key: "Upgraded",
	): TypedContractEvent<
		UpgradedEvent.InputTuple,
		UpgradedEvent.OutputTuple,
		UpgradedEvent.OutputObject
	>;

	filters: {
		"AdminChanged(address,address)": TypedContractEvent<
			AdminChangedEvent.InputTuple,
			AdminChangedEvent.OutputTuple,
			AdminChangedEvent.OutputObject
		>;
		AdminChanged: TypedContractEvent<
			AdminChangedEvent.InputTuple,
			AdminChangedEvent.OutputTuple,
			AdminChangedEvent.OutputObject
		>;

		"BeaconUpgraded(address)": TypedContractEvent<
			BeaconUpgradedEvent.InputTuple,
			BeaconUpgradedEvent.OutputTuple,
			BeaconUpgradedEvent.OutputObject
		>;
		BeaconUpgraded: TypedContractEvent<
			BeaconUpgradedEvent.InputTuple,
			BeaconUpgradedEvent.OutputTuple,
			BeaconUpgradedEvent.OutputObject
		>;

		"Initialized(uint8)": TypedContractEvent<
			InitializedEvent.InputTuple,
			InitializedEvent.OutputTuple,
			InitializedEvent.OutputObject
		>;
		Initialized: TypedContractEvent<
			InitializedEvent.InputTuple,
			InitializedEvent.OutputTuple,
			InitializedEvent.OutputObject
		>;

		"PasskeyZkAccountInitialized(address,tuple)": TypedContractEvent<
			PasskeyZkAccountInitializedEvent.InputTuple,
			PasskeyZkAccountInitializedEvent.OutputTuple,
			PasskeyZkAccountInitializedEvent.OutputObject
		>;
		PasskeyZkAccountInitialized: TypedContractEvent<
			PasskeyZkAccountInitializedEvent.InputTuple,
			PasskeyZkAccountInitializedEvent.OutputTuple,
			PasskeyZkAccountInitializedEvent.OutputObject
		>;

		"Upgraded(address)": TypedContractEvent<
			UpgradedEvent.InputTuple,
			UpgradedEvent.OutputTuple,
			UpgradedEvent.OutputObject
		>;
		Upgraded: TypedContractEvent<
			UpgradedEvent.InputTuple,
			UpgradedEvent.OutputTuple,
			UpgradedEvent.OutputObject
		>;
	};
}
